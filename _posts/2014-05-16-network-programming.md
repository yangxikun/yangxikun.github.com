---
layout: post
title: "select、poll、epoll学习"
description: ""
category: Linux
tags: [网络编程]
---
{% include JB/setup %}

参考资料：[select、poll、epoll之间的区别总结](http://www.cnblogs.com/Anker/p/3265058.html)、[select,poll,epoll的内部机制调研](http://wenku.baidu.com/view/31f51d7da26925c52cc5bf4e.html)

#### 基本概念
- - -

* 阻塞：进程访问数据，当数据尚未就绪，进程等待。
* 非阻塞：进程访问数据，当数据尚未就绪，进程不等待。
* 同步：当数据就绪时，数据从内核空间拷贝到用户空间时，进程等待。
* 异步：当数据就绪时，数据从内核空间拷贝到用户空间时，进程不等待。

<!--more-->

#### 进程状态的转换
- - -

![IO](/assets/img/201405180102.png)

#### 五种I/O模型
- - -

![IO](/assets/img/201405180101.png)

#### select
- - -

执行流程（抽象层面来看）：

1. 进入内核态，将`fd_set`从用户空间拷贝到内核空间；
1. 扫描文件描述符（这个过程会把当前进程挂到相应文件描述符fd对应的设备等待队列上，就是添加了个数据结构，这个数据结构带有一个回调函数，供驱动程序调用，该回调函数会激活select），判断是否有感兴趣的事情发生，根据情况设置相应的`fd_set`的值；
1. 如果有感兴趣的事情发生了，那么select就会删除所监视的fd对应的设备等待队列上的数据结构，接着返回用户态，否则，select会暂时挂起，直到某个fd感兴趣的事情发生了，被激活，或者挂起时间结束了，被再次调度，然后重复步骤3。（如果设置了select的timeout，那么当timeout一到时，就必须返回用户态）；
1. 在用户态，同样需要扫描监视的fd，看那个fd发生了感兴趣的事情，然后执行I/O操作（数据从内核空间到用户空间的拷贝）；
1. 回到步骤1。

缺点：

* 单个进程可监视的fd数量被限制，select是使用结构体数组存放fd的；
* 用户空间和内核空间在传递该结构时复制开销大；
* 多次对fd集合进行线性扫描，和挂载/删除设备等待队列上的数据结构。

#### poll
- - -

poll的内核态操作和select一样，只是向上层用户态提供的接口不同。

poll使用链表来存放fd，所以没有fd数量限制，其他缺点与select相同。

#### epoll
- - -

1. 调用`epoll_create()`，该函数生成一个epoll专用的文件描述符。它其实是在内核申请空间，用来存放监视的fd相关信息。
1. 通过`epoll_ctl()`，将当前进程挂到监视的fd相应的设备等待队列上，同样也是添加了个数据结构，但这个数据结构所带的回调函数却与select/poll不同（关键所在），该回调函数被设备驱动程序调用时，会向某个就绪链表插入相应的fd；
1. 调用`epoll_wait()`，该函数主要就是查看就绪链表中是否已经有fd了，如果没有，则暂时挂起，有则返回；
1. 在用户态遍历收集到的就绪fd，执行相应的I/O操作（数据从内核空间到用户空间的拷贝）；
1. 回到步骤3。

相比于select的缺点：

* epoll的fd为进程最大可以打开的文件数目；
* epoll对于监视的fd，在相应的设备等待队列上只挂一次；
* epoll无需多次扫描fd集，只是在`epoll_ctl()`时，才线性的扫描了一次。
