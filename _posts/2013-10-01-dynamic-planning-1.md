---
layout: post
title: "动态规划--矩阵连乘问题"
description: ""
category: 算法
tags: [算法]
---
{% include JB/setup %}

#### 问题描述

给定n个矩阵{A1,A2,...,An},其中Ai与Ai+1是可乘的，i=1，2，...，n-1。求使用矩阵结合律使n个矩阵的连乘积需要的数乘次数最少。

<!--more-->
由于矩阵乘法满足结合律，故计算矩阵的连乘积可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。

完全加括号的矩阵连乘积可递归地定义为：

1. 单个矩阵时完全加括号的；
2. 矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)；

例如，矩阵连乘积A1A2A3A4可以有以下几种不同的完全加括号方式：

\(A1\(A2\(A3A4\)\)\)，\(A1\(\(A2A3\)A4\)\)，\(\(A1A2\)\(A3A4\)\)等，不同完全加括号的连乘积所需的数乘次数不同，我们要求的就是数乘次数最少的完全加括号方式。

#### 分析最优子结构

在递归分治中，我们不需要对问题分析最优子结构，因为递归分治不是用于求最优解的，它是将原问题划分为子问题，逐个求解出子问题后合并为原问题的解.而动态规划用于求解问题的最优解，所以需要对问题的最优子结构进行分析，且动态规划每个子问题的解并不是一起合并为原问题的解，而是从子问题的解中挑选出合适的解得出父问题的解。

最优子结构是指原问题的最优解包含着其子问题的最优解，例如:假设\(A1\(A2\(A3A4\)\)\)是矩阵连乘积A1A2A3A4的最优解，那么A2\(A3A4\)是其子问题矩阵连乘积A2A3A4的最优解。

要使用动态规划算法求解问题，就必须先证明原问题具有最优子结构性质，因为只有符合这个性质，原问题的最优解才可以从子问题的最优解中得出。这和递归分治类似，都是自底向上的求解方式，从子问题的解得出原问题的解。

证明矩阵连乘积问题具有最优子结构：

将矩阵连乘积AiAi+1...Aj简记为A\[i:j\]。考察计算A\[1:n\]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，`1<=k<n`，则其相应的完全加括号方式为\(\(A1...Ak\)\(Ak+1...An\)\)。依此次序，先计算A\[1:k\]和A\[k+1:n\]，然后将计算结果相乘得到A\[1:n\]，依此计算顺序总计算量为A\[1:k\]的计算量加上A\[k+1:n\]的计算量，再加上A\[1:k\]和A\[k+1:n\]相乘的计算量。

问题的关键点在于：计算A\[1:n\]的最优次序所包含的计算矩阵子链A\[1:k\]和A\[k+1:n\]的次序也是最优的，即原问题具有最优子结构性质.

反证法证明：如果存在一个计算A\[1:k\]的次序需要的计算量更少，则用此次序替换原来的次序，得到的计算A\[1:n\]的计算量将比最优次序所需计算量更少，这是一个矛盾。

#### 建立递归关系

这是动态规划的第二步。设计算A\[i:j\]，`1<=i<=j<=n`，所需的最少数乘次数为m\[i\]\[j\]，则原问题的最优值为m\[1\]\[n\]。

当`i=j`时，A\[i:j\]=Ai为单一矩阵，所以m\[i\]\[i\]=0，i=1，2，...，n;

当`i<j`时，可利用最优子结构性质来计算m\[i\]\[j\].事实上，若计算A\[i:j\]的最优次序在Ak和Ak+1之间断开，`i<=k<j`，则m\[i\]\[j\]=m\[i\]\[k\]+m\[k+1\]\[j\]+Pi-1PkPj    `i<=k<j`。因此，k是这j-i个位置中使计算量达到最小的那个位置。从而m\[i\]\[j\]可以递归地定义为

m\[i\]\[j\] = 0    `i = j`

m\[i\]\[j\] = min{m\[i\]\[k\]+m\[k+1\]\[j\]+Pi-1PkPj}    `i < j`

Pi-1PkPj是指数组Pi-1Pk和PkPj相乘所需计算量。用s\[i\]\[j\]记录k可得出最优值m\[i\]\[j\]的断开点，并可递归地由s\[i\]\[j\]构造出相应的最优解。

#### 算法代码

{% highlight cpp linenos %}
void MatrixChain(int *p, int n, int **m, int **s)
{
    //m[i][j]记录A[i:j]最少计算量的值,s[i][j]记录断开点
    for (int i = 1; i <= n; i++) m[i][i] = 0;
    for (int r = 2; r <= n; r++)//步长控制
        for (int i = 1; i <= n-r+1; i++) {
            int j = i+r-1;
            m[i][j] = m[i+1][j]+p[i-1]*p[i]*p[j];
            s[i][j] = 1;
            for (int k = i+1; k < j; k++) {
                int t = m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];
                if (t < m[i][j]) {m[i][j] = t;s[i][j] = k;}
            }
        }
}

void TraceBack(int i, int j, int **s)
{
    //根据s数组,递归求A[i:j]的最优解
    if(i == j) return;
    TraceBack(i, s[i][j], s);
    TraceBack(s[i][j]+1, j, s);
    cout<<"Multiply A"<<i<<","<<s[i][j];
    cout<<" and A"<<(s[i][j]+1)<<","<<j<<endl;
}
{% endhighlight %}

如果连矩阵乘积为A1A2A3A4A5,则代码执行时,计算子矩阵链顺序为:

m\[1\]\[2\],m\[2\]\[3\],m\[3\]\[4\],m\[4\]\[5\]

m\[1\]\[3\],m\[2\]\[4\],m\[3\]\[5\]

m\[1\]\[4\],m\[2\]\[5\]

m\[1\]\[5\]