---
layout: post
title: "递归与分治--格雷码"
description: ""
category: 算法
tags: [算法]
---
{% include JB/setup %}

###格雷码

>Gray码是一个长度为2^n的序列.序列中无相同元素,每个元素都是长度为n位的(0,1)串,相邻元素恰好只有一位不同.

>题目中要求相邻元素恰好只有一位不同,那就不能通过简单的全排列来解,在递归的过程应该需要做一些选择判断之类的.

>将排列画成如下图:

<!--more-->
![gray1](/assets/img/201309230301.png)

>由树从左到右可得000,001,010,011,可见这并不符合要求.如果将排列画成下图:

![gray2](/assets/img/201309230302.png)

>由树从左到右可得000,001,011,010,可见符合要求,再仔细分析可得,当从根结点到叶子结点的父结点路径上,如果有偶数个0,则它的左右孩子为01,如果有奇数个0,则它的左右孩子为10,这样就能保证每个相邻元素之间只有一位不同.

>所以在递归函数中,最关键的一点就是,判断当前序列0的个数时偶数还是奇数,然后采用不同的递归顺序调用.核心代码如下:

{% highlight cpp linenos %}
void gray( char t /*...省略部分参数*/ ) {
    if ( level == n ) {//递归出口
        //输出元素
    }
    /*...省略部分代码*/
    if ( is_even( c ) ) {//如果时偶数个0
        gray( '0' );
        gray( '1' );
    }else{
        gray( '1' );
        gray( '0' );
    }
}
{% endhighlight %}